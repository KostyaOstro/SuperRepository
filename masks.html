<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            padding: 0px;
            margin: 0px
        }
    </style>

</head>
<link href="https://fonts.googleapis.com/css?family=Roboto:900" rel="stylesheet">
<script src="javascripts/three.js"></script>
<script src="javascripts/orbitcontrols.js"></script>

<body>
    <script>
        var time = 0;
        var grid = {
            h: 7,
            v: 7,
            side: 200,
            border: 10,
            padding: 5,
            get copies() {
                return this.h * this.v;
            }
        }
        var w = grid.h * grid.side + grid.border * 2 + grid.padding * (grid.h - 1);
        var h = grid.v * grid.side + grid.border * 2 + grid.padding * (grid.v - 1);



        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(65, w / h, 0.01, 2000);
        camera.position.set(w / 2, h / 2, w);

        var renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(w, h);
        document.body.appendChild(renderer.domElement);


        var maskPivot = [];
        var unit = grid.side / 5;
        var bodyGeom = [];
        var bodyOb = [];
        var l = 0;
        for (var ii = 0; ii < grid.v; ii++) {
            for (var jj = 0; jj < grid.h; jj++) {
                maskPivot[bodyOb.length] = new THREE.Object3D();
                ob = {
                    x: grid.border + jj * grid.side + grid.side / 2 + grid.padding * (jj - 1),
                    y: grid.border + ii * grid.side + grid.side / 2 + grid.padding * (ii - 1),
                    height: unit * 3,
                    width: unit * 2,
                    geometry: 0,
                    seed: Math.round(Math.random() * 3),
                    color: bodyColor(),
                    eye: {
                        x: unit / 2 + Math.random() * unit / 4,
                        y: Math.random() * unit / 4,
                        type: [
                            Math.round(Math.random() * 4),
                            Math.round(Math.random() * 4)
                        ],
                        size: [
                            unit / 2 + Math.random() * unit / 2,
                            unit / 2 + Math.random() * unit / 2
                        ],
                        seed: 1,
                        color: ['white', rColor()],

                    },
                    mouth: {
                        y: -Math.random() * unit / 8 - unit / 2,
                        type: Math.round(Math.random() * 3),
                        color: 'white',
                        size: unit / 4 + Math.random() * unit / 2,
                    },
                    feather: {
                        number: Math.random() * 20 + 20,
                        angle: Math.PI * 2 * Math.random() + Math.PI / 4,
                        color: rColor(),
                        length: unit * Math.random() + unit * 1,
                        correlationSize: Math.random() * unit
                    },
                    construct() {
                        constructBody(this);
                        eyeConstruct(this.eye, this.x, this.y);
                        featherConstruct(this);
                        mouthConstruct(this);
                    }
                }

                bodyOb.push(ob);
                bodyOb[bodyOb.length - 1].construct();
                maskPivot[bodyOb.length - 1].position.set(ob.x, ob.y, 0)
                scene.add(maskPivot[bodyOb.length - 1]);
                //bodyOb.eye.costruct();

            }

        }








        function mouthConstruct(obj) {
            // var mouthPivot = []

            var mouthPivot = new THREE.Object3D();
            switch (obj.mouth.type) {
                case 0: //line
                    var mouthGeom = new THREE.PlaneGeometry(
                        obj.mouth.size / 4,
                        obj.mouth.size,
                        1,
                        1
                    );
                    var mouthMat = new THREE.MeshBasicMaterial({
                        color: obj.mouth.color
                    });
                    var mouthMesh = new THREE.Mesh(mouthGeom, mouthMat);

                    var seed = Math.round(Math.random() * 2)
                    if (seed > 2) {
                        mouthMesh.rotation.z = Math.PI / 2
                    }
                    mouthPivot.add(mouthMesh);
                    break;
                case 1: //smile-sad
                    var mouthGeom = new THREE.RingGeometry(
                        obj.mouth.size / 2 * 0.6,
                        obj.mouth.size * 0.6,
                        20,
                        1,
                        0,
                        Math.PI
                    )
                    var mouthMat = new THREE.MeshBasicMaterial({
                        color: obj.mouth.color
                    });
                    var mouthMesh = new THREE.Mesh(mouthGeom, mouthMat);
                    var seed = Math.round(Math.random() * 2);
                    if (seed > 2) {
                        mouthMesh.rotation.z = Math.PI
                    };
                    mouthPivot.add(mouthMesh);

                    break;
                case 2: //o
                    var mouthGeom = new THREE.RingGeometry(
                        obj.mouth.size / 2 * 0.6,
                        obj.mouth.size * 0.6,
                        20,
                        1
                    )
                    var mouthMat = new THREE.MeshBasicMaterial({
                        color: obj.mouth.color
                    });
                    var mouthMesh = new THREE.Mesh(mouthGeom, mouthMat);
                    mouthPivot.add(mouthMesh);

                    break;
                default: //cross
                    var mouthGeom = new THREE.PlaneGeometry(
                        obj.mouth.size / 4,
                        obj.mouth.size,
                        1,
                        1
                    );
                    var mouthMat = new THREE.MeshBasicMaterial({
                        color: obj.mouth.color
                    });
                    var mouthMesh1 = new THREE.Mesh(mouthGeom, mouthMat);
                    mouthMesh1.rotation.z = Math.PI / 4;
                    mouthPivot.add(mouthMesh1);
                    var mouthMesh2 = new THREE.Mesh(mouthGeom, mouthMat);
                    mouthMesh2.rotation.z = -Math.PI / 4;
                    mouthPivot.add(mouthMesh2);
                    break;
            }

            mouthPivot.position.set(0, obj.mouth.y, unit / 2);
            maskPivot[bodyOb.length - 1].add(mouthPivot)

        }

        function featherConstruct(obj) {

            var Aunits = obj.feather.number;
            for (i = 0; i < Aunits; i++) {
                var fcolor = bodyColor() //obj.feather.color;
                var h = obj.feather.length + Math.random() * obj.feather.correlationSize;
                var fUnitPivot = new THREE.Object3D();
                var fg = new THREE.PlaneGeometry(unit / 10, h, 1, 1);
                var fm = new THREE.MeshBasicMaterial({
                    color: fcolor
                });
                var fUnit = new THREE.Mesh(fg, fm);
                fUnit.position.y = h / 2;
                fUnit.position.z = -unit / 2;
                fUnitPivot.add(fUnit);
                fUnitPivot.rotation.z = -obj.feather.angle / 2 + i / Aunits * obj.feather.angle;
                maskPivot[bodyOb.length - 1].add(fUnitPivot);
            }
        }




        function eyeConstruct(obj, gx, gy) {
            // bodyGeom.verticesNeedUpdate = true;
            var eyePivot = []
            for (var i = 0; i < 2; i++) {
                eyePivot[i] = new THREE.Object3D();
                switch (obj.type[i]) {
                    // case 0: //circle
                    //     var eyeGeom = new THREE.CircleGeometry(
                    //         obj.size[i] / 2,
                    //         20
                    //     )
                    //     var eyeMat = new THREE.MeshBasicMaterial({
                    //         color: obj.color[0]
                    //     });
                    //     var eyeMesh1 = new THREE.Mesh(eyeGeom, eyeMat);
                    //     eyePivot[i].add(eyeMesh1);


                    //     var eyeGeom = new THREE.CircleGeometry(
                    //         obj.size[i] * 0.3,
                    //         20
                    //     )
                    //     var eyeMat = new THREE.MeshBasicMaterial({
                    //         color: obj.color[1]
                    //     });
                    //     var eyeMesh2 = new THREE.Mesh(eyeGeom, eyeMat);
                    //     eyeMesh2.position.z = unit / 5;
                    //     eyePivot[i].add(eyeMesh2);
                    //     break;
                    case 1: //square
                        var eyeGeom = new THREE.PlaneGeometry(
                            obj.size[i],
                            obj.size[i],
                            1,
                            1
                        )

                        var eyeMat = new THREE.MeshBasicMaterial({
                            color: obj.color[0]
                        });
                        var eyeMesh1 = new THREE.Mesh(eyeGeom, eyeMat);
                        eyeMesh1.rotation.z = Math.PI / 4;
                        eyePivot[i].add(eyeMesh1);
                        var eyeMat = new THREE.MeshBasicMaterial({
                            color: obj.color[1]
                        });
                        var eyeMesh2 = new THREE.Mesh(eyeGeom, eyeMat);
                        eyeMesh2.rotation.z = Math.PI / 4;
                        eyeMesh2.position.z = unit / 10;
                        var scale = 0.6;
                        eyeMesh2.scale.set(scale, scale, scale);
                        eyePivot[i].add(eyeMesh2);

                        break;
                    case 2: //ring
                        var eyeGeom = new THREE.RingGeometry(
                            obj.size[i] / 2 * 0.6,
                            obj.size[i] * 0.6,
                            20,
                            1
                        )
                        var eyeMat = new THREE.MeshBasicMaterial({
                            color: obj.color[0]
                        });
                        var eyeMesh = new THREE.Mesh(eyeGeom, eyeMat);
                        eyePivot[i].add(eyeMesh);

                        break;
                    case 3: //cross
                        var eyeGeom = new THREE.PlaneGeometry(
                            obj.size[i] / 4,
                            obj.size[i],
                            1,
                            1
                        );
                        var eyeMat = new THREE.MeshBasicMaterial({
                            color: obj.color[0]
                        });
                        var eyeMesh1 = new THREE.Mesh(eyeGeom, eyeMat);
                        eyeMesh1.rotation.z = Math.PI / 4;
                        eyePivot[i].add(eyeMesh1);
                        var eyeMesh2 = new THREE.Mesh(eyeGeom, eyeMat);
                        eyeMesh2.rotation.z = -Math.PI / 4;
                        eyePivot[i].add(eyeMesh2);
                        break;
                    default: //cross
                        var eyeGeom = new THREE.PlaneGeometry(
                            obj.size[i],
                            obj.size[i] / 4,
                            1,
                            1
                        );
                        var eyeMat = new THREE.MeshBasicMaterial({
                            color: obj.color[0]
                        });
                        var eyeMesh = new THREE.Mesh(eyeGeom, eyeMat);
                        eyePivot[i].add(eyeMesh);
                        break;
                }
                //scene.add(eyePivot[i]);
                // var xx = gx + obj.x;
                // var yy = obj.y + gy;
                eyePivot[i].position.set(obj.x, obj.y, unit / 5);
                obj.x = -obj.x;
                maskPivot[bodyOb.length - 1].add(eyePivot[i])
            }
        }

        var mouth = {
            x: 0,
            y: unit / 2,
            type: 0, //Math.round(Math.random()*3),
            size: unit / 4,
            seed: 1,
            color: [rColor(), rColor()],
            costruct() {
                mouthConstruct(this)
            }
        }











        animate();



        function animate() {
            for (var i = 0; i < grid.copies; i++) {
                maskPivot[i].rotation.y = Math.sin(time / 50 + i / 10) * 0.2;
            }
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
            time++
        }


        function rColor() {
            var seed = Math.round(Math.random() * 3);
            switch (seed) {
                case 1:
                    var r = 255;
                    var g = 255;
                    var b = 255;
                    break;
                // case 2:
                //     var r = 0; // Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                //     var g = Math.round(Math.random() * 64) + 128;
                //     var b = Math.round(Math.random() * 64) + 128;
                //     break;

                case 3:
                    var r = Math.round(Math.random() * 32) + 32;
                    var g = 0;
                    var b = r;
                    break;
                default:
                    var r = Math.round(Math.random() * 64) + 128;
                    var g = 0; //Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                    var b = Math.round(Math.random() * 64) + 128;
                    break;
            }
            var rgb = "rgb(" + r + "," + g + "," + b + ")";
            return rgb;
        }



        function bodyColor() {
            var seed = Math.round(Math.random() * 3);
            switch (seed) {
                // case 1:
                //     var r = Math.round(Math.random() * 64) + 64;
                //     var g = 0; //Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                //     var b = Math.round(Math.random() * 64) + 64;
                //     break;
                // case 2:
                //     var r = 0; // Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                //     var g = Math.round(Math.random() * 64) + 64;
                //     var b = Math.round(Math.random() * 64) + 64;
                //     break;

                case 3:
                    var r = Math.round(Math.random() * 32) + 32;
                    var g = 0;
                    var b = Math.round(Math.random() * 64) + 64;
                    break;
                default:
                    var r = Math.round(Math.random() * 64) + 64;
                    var g = 0; //Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                    var b = Math.round(Math.random() * 64) + 64;
                    break;
            }
            var rgb = "rgb(" + r + "," + g + "," + b + ")";
            return rgb;
        }



        function constructBody(obj) {
            bodyGeom = new THREE.PlaneGeometry(
                obj.width,
                obj.height,
                2,
                3
            );

            switch (obj.seed) {
                case 0: //circle
                    bodyGeom.vertices[0].x = -0.2 * unit; //left top
                    bodyGeom.vertices[2].x = 0.2 * unit; //right top
                    bodyGeom.vertices[3].x = -unit; //centre left
                    bodyGeom.vertices[6].x = -unit; //centre left
                    bodyGeom.vertices[5].x = unit; //centre right
                    bodyGeom.vertices[8].x = unit; //centre right
                    bodyGeom.vertices[9].x = -0.2 * unit; //left bottom
                    bodyGeom.vertices[11].x = 0.2 * unit; //right bottom
                    break;

                case 1: //shield
                    bodyGeom.vertices[0].x = -unit; //left top
                    bodyGeom.vertices[2].x = unit; //right top
                    bodyGeom.vertices[3].x = -unit; //centre left
                    bodyGeom.vertices[6].x = -unit * 0.8; //centre left
                    bodyGeom.vertices[5].x = unit; //centre right
                    bodyGeom.vertices[8].x = unit * 0.8; //centre right
                    bodyGeom.vertices[9].x = 0; //left bottom
                    bodyGeom.vertices[11].x = 0; //right bottom
                    break;

                case 2: //rhombus
                    bodyGeom.vertices[0].x = -0.2 * unit; //left top
                    bodyGeom.vertices[2].x = 0.2 * unit; //right top
                    bodyGeom.vertices[3].x = -unit * 0.6; //centre left
                    bodyGeom.vertices[6].x = -unit; //centre left
                    bodyGeom.vertices[5].x = unit * 0.6; //centre right
                    bodyGeom.vertices[8].x = unit; //centre right
                    bodyGeom.vertices[9].x = 0; //left bottom
                    bodyGeom.vertices[11].x = 0; //right bottom
                    break;

                default: //square inside
                    bodyGeom.vertices[0].x = -unit; //left top
                    bodyGeom.vertices[2].x = unit; //right top
                    bodyGeom.vertices[3].x = -unit * 0.8; //centre left
                    bodyGeom.vertices[6].x = -unit * 0.8; //centre left
                    bodyGeom.vertices[5].x = unit * 0.8; //centre right
                    bodyGeom.vertices[8].x = unit * 0.8; //centre right
                    bodyGeom.vertices[9].x = -unit; //left bottom
                    bodyGeom.vertices[11].x = unit; //right bottom
                    break;
            }
            bodyGeom.verticesNeedUpdate = true;

            for (i = 0; i < bodyGeom.faces.length; i++) {
                var r =Math.random(); //Math.round(Math.random() * 64) + 64;
                var g = 0; //Math.round(Math.abs(Math.sin(Math.random()) * 128)) + 128;
                var b = Math.round(Math.random() * 64) + 64;

                bodyGeom.faces[i].color.r=(Math.round(Math.random() * 64) + 64)/256;
                bodyGeom.faces[i].color.g=0;
                bodyGeom.faces[i].color.b=(Math.round(Math.random() * 64) + 64)/256;
            }
            var bodyMat = new THREE.MeshBasicMaterial({
                //color: obj.color,
                vertexColors: THREE.FaceColors
            });
            var bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);

            maskPivot[bodyOb.length - 1].add(bodyMesh);

        }
    </script>

</body>

</html>