<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="/javascripts/three.js"></script>
    <script src="/javascripts/myLib.js"></script>
    <script id = 'fragShader' type = 'x-shader/x-fragment'>
        uniform sampler2D texture1;
        uniform float time;
        varying vec2 mv;

        void main(){
            //vec2 mv = gl_FragCoord.xy / 1024. ;
            vec4 img = texture2D(texture1, mv.xy);
            float col = img.r;
            gl_FragColor = vec4(vec3(mv.x), 1.);
        }
    </script>
    <script id = 'verShader' type = 'x-shader/x-vertex'>
        uniform float time;
        varying vec2 mv;
        void main(){
            mv = uv ;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        }
    </script>
    <title>Document</title>
</head>

<body>
    <script>
        var time = 0;
        var w = h = 1024;

        var canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        document.body.appendChild(canvas);
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = "black";

        var fs = h / 4;
        var lh = .9;
        ctx.font = fs + 'px arial';
        ctx.textAlign = "center";
        ctx.fillText(
            'HELLO',
            w / 2,
            h / 2 + fs * lh / 2
        )





        if (ctx) {
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(90, w / h, .01, 2000);
            camera.position.z = 70;
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(w, h);
            document.body.appendChild(renderer.domElement);
            var mesh = [];
            var pivot = new THREE.Object3D();
            var copies = 80;
            var h = .5;
            var points = 100;
            var tex = new THREE.CanvasTexture(canvas);

            renderer.shadowMap.enabled = true;
            var ambientLight = new THREE.AmbientLight(new THREE.Color('blue'), .4);
            scene.add(ambientLight);

            var pointLight = new THREE.PointLight(new THREE.Color('red'), 1.);
            scene.add(pointLight);
            pointLight.position.set(100,30,150);

            pointLight.castShadow = true;
            pointLight.shadow.bias -= 0.0001;


            var uniforms = {
                'texture1': {
                    value: tex
                },
                time: {
                    type: "f",
                    value: 0
                }
            };


            for (let j = 0; j < copies; j++) {
                var shape = new THREE.Shape();

                for (let i = 0; i < points; i++) {
                    let of = 3 + Math.cos(j / copies * 10) * 1;
                    let d = 55 ;//* Math.cos(j / copies * 10) + 25;
                    let a = Math.PI / points * i * 2;
                    let x = Math.cos(a) * d + Math.tan(i / points * 200) * of / 50;
                    let y = Math.sin(a) * d + Math.sin(i / points * 200) * of ;

                    if (i == 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y)

                }
                var exsettings = {
                    steps: 2,
                    depth: h,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelSegments: 1
                };
                var geometry = new THREE.ExtrudeGeometry(shape, exsettings);
                var material = new THREE.MeshStandardMaterial({
                    // uniforms: uniforms,
                    // fragmentShader: document.getElementById('fragShader').textContent,
                    // vertexShader: document.getElementById('verShader').textContent,
                });
                mesh[j] = new THREE.Mesh(geometry, material);
                pivot.add(mesh[j]);
                mesh[j].position.z = h * j - copies * h / 2;
               // mesh[j].castShadow = true;
                //mesh[j].receiveShadow = true;
            }
            scene.add(pivot);
            pivot.rotation.x = Math.PI / 2;
            pivot.rotation.y = Math.PI / 2
            animate();
        }

        function animate() {
            //pivot.rotation.y += .001;
            for (let j = 0; j < copies; j++) {
                mesh[j].rotation.z += Math.cos(j / copies) * 0.01;
            }
            uniforms.time.value = time;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
            time += .01;
        }
    </script>
</body>

</html>