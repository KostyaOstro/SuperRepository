<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="/javascripts/three.js"></script>
    <script src="/javascripts/myLib.js"></script>
    <script id='fragmentShader2' type='x-shader/x-fragment'>
        uniform float time;
        varying vec3 n;
        varying vec3 p;
        varying vec4 p2;
        varying vec4 n2;
        varying vec2 vv;

        void main(){
            vec2 gv = gl_FragCoord.xy / 1024.;
            float i = 100.;
            gv = fract(gv * i );
            float r = .5 * (1. - n2.y);
            float r2 = .5 * (1. - n2.x / .5);
            float l = step(r,length(gv - .5)) ;
            float l2 = step(r2,length(gv - .5)) ;
            gv = floor(gv * 20.) / 20.;
           //floor(max(n2.y, .2) * 5.) / 5.;
            
           
            if(!gl_FrontFacing)l = .01;
            gl_FragColor = vec4(vec3(l, 0.,1.- l2), 1.);
        }
    </script>
    <script id='fragmentShader' type='x-shader/x-fragment'>
        uniform float time;
        varying vec3 n;
        varying vec3 p;
        varying vec4 p2;
        varying vec4 n2;
        varying vec2 vv;

        void main(){
            vec2 gv = gl_FragCoord.xy / 1024.;
            float i = 100.;
            gv = fract(gv * i );
            float r = .5 * (1. - n2.y);
            float r2 = .5 * (1. - n2.x / .5);
            float l = step(r,length(gv - .5)) ;
            float l2 = step(r2,length(gv - .5)) ;
            gv = floor(gv * 20.) / 20.;
           //floor(max(n2.y, .2) * 5.) / 5.;
            
           
            if(!gl_FrontFacing)l = .01;
            gl_FragColor = vec4(vec3(1. - l, 0.,l2), 1.);
        }
    </script>
    <script id='vertexShader' type='x-shader/x-vertex'>
        uniform float time;
        varying vec3 n;
        varying vec3 p;
        varying vec4 p2;
        varying vec4 n2;
        varying vec2 vv;

        void main(){
            vv =uv;
            n = normal;
            n2 = projectionMatrix * modelViewMatrix * vec4(normal, 0.);
            p = position;
            p2 = modelViewMatrix * vec4(position, 1.);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        }
    </script>
    <script id='fragmentShader3' type='x-shader/x-fragment'>
        mat2 rotate(float a){

            return mat2(cos(a), - sin(a),
                        sin(a), cos(a));
        }



        uniform sampler2D texture1;
        uniform float time;
        varying vec3 n;
        varying vec3 p;
        varying vec4 p2;
        varying vec4 n2;
        varying vec2 vv;

        void main(){
            vec2 gv3 = gl_FragCoord.xy / 1024.;
            vec2 gv2 = gl_FragCoord.xy / 1024.;
            vec2 gv = vv;
            float i = 100.;
            gv2 = fract(gv2 * i);
            
            float r2 = .5 * (1. - n2.x / .5);

            float sc = 2.;
            gv = floor(gv * i * 8.) / i / 8.;
            gv.y /= sc;
            gv.y += (sc - 1.) / sc / 2.;
            gv.x *= 4.;
            //gv.y += floor(cos(gv.x * 60. + time))/ 70.;
            gv.x += floor(cos(gv.y * 60. + time))/ 70.;
            //gv.x += fract(cos(floor(gv.y * i)) )/ 50.;
            
            vec4 img = texture2D(texture1,gv);
            
            float l = step(.5 * (1. - img.r) * abs(n2.z), length(gv2 - .5));
            vec3 col = vec3(1.);
            if(l > .8)discard;
            if(!gl_FrontFacing)col = vec3(1.,0.,0.);
            gl_FragColor = vec4(col, 1.);
        }
    </script>
    <title>Document</title>
</head>

<body>
    <script>
        var time = 0.;
        var w = h = 1024;

        var canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        //document.body.appendChild(canvas);
        var ctx = canvas.getContext("2d");

        var fs = h / 5;
        var lh = .8;
        ctx.font = 'bold ' + fs + 'px Arial';
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = 'black';
        ctx.textAlign = "center";
        var txt = "CORALLS";
        for (let j = 0; j < 1; j++) {
            ctx.fillText(
                txt,
                w / 2,
                h / 2 + fs / 2 + j * lh * fs
            )
        }


        if (ctx) {

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(65, w / h, .01, 2000);
            camera.position.z = 100;
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(w, h);
            document.body.appendChild(renderer.domElement);

            var pivot = new THREE.Object3D();
            var tube = [];
            var tex = new THREE.CanvasTexture(canvas);
            var uniforms = {
                time: {
                    type: 'f',
                    value: 0.
                },
                'texture1': {
                    value: tex
                }
            }



            for (var i = 0; i < 80; i++) {
                let k1 = rSeed(10) + 1;
                let k2 = rSeed(15) + 1;
                let k3 = random(10, 50);
                let r = random(0.1, 4);


                var path = new THREE.Path();
                path.getPoint = function (t) {
                    let x = t * k3;
                    let y = Math.cos(t * k1) * k2 * t;
                    let z = 0;
                    return new THREE.Vector3(x, y, z);
                };

                var mesh = new THREE.TubeGeometry(path, 60, r, 10);


                var material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    side: THREE.DoubleSide,
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                });

                if (i % 2 == 0) {
                    material.fragmentShader = document.getElementById('fragmentShader2').textContent;
                }
                tube[i] = new THREE.Mesh(mesh, material);
                tube[i].rotation.x = random(0, Math.PI * 2);
                tube[i].rotation.y = random(0, Math.PI * 2);
                tube[i].rotation.z = random(0, Math.PI * 2);
                pivot.add(tube[i]);
            }
            var sphere = [];
            for (var i = 0; i < 20; i++) {
                let r = random(1, 4);
                var mesh = new THREE.SphereBufferGeometry(r, 20, 20);


                var material = new THREE.ShaderMaterial({
                    uniforms: uniforms,

                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                });

                if (i % 2 == 0) {
                    material.fragmentShader = document.getElementById('fragmentShader2').textContent;
                }
                sphere[i] = new THREE.Mesh(mesh, material);
                sphere[i].position.x = random(-50, 50);
                sphere[i].position.y = random(-50, 50);
                sphere[i].position.z = random(-50, 50);
                pivot.add(sphere[i]);

            }
            scene.add(pivot);


            var geometry = new THREE.CylinderGeometry(50, 50, 50, 40, 50, true);
            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                side: THREE.DoubleSide,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader3').textContent,
            });
            var plane1 = new THREE.Mesh(geometry, material);
            scene.add(plane1);
            scene.rotation.y = -.6;

            // var plane2 = new THREE.Mesh(geometry, material);
            // pivot.add(plane2);
            // plane2.position.y = 25;

            animate()
        }

        function animate() {
             plane1.rotation.y -= .01;
            // plane2.rotation.y += .001;
            // plane.rotation.x -= .01;
            // plane.rotation.z -= .01;
            pivot.rotation.y += .01;
            uniforms.time.value = time;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
            time += .01;
        }
    </script>
</body>

</html>