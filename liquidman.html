<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="/javascripts/three.js"></script>
    <script src="/javascripts/objloader.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto:900" rel="stylesheet">
</head>

<body>
    <script>
        var w = h = 1024;
        var time = 0;
        var renderer;
        var canvas;
        var ctx;
        var canvas2;
        var ctx2;
        var scene;
        var camera;
        var mesh = [];
        var l;
        var cube;
        var gsc, bg;
        var pivot;
        var strokeColor;

        var drama = {
            copies: 32,
            x: [],
            y: [],
            vx: [],
            vy: [],
            s: [],
            color: [],
            type: [],
            init() {
                var copies = this.copies;
                var x = this.x;
                var y = this.y;
                var vx = this.vx;
                var vy = this.vy;
                var s = this.s;
                var color = this.color;
                var type = this.type;

                for (let i = 0; i < copies; i++) {
                    x[i] = random(0, w);
                    y[i] = random(0, h);
                    vx[i] = random(-1, 1);
                    vy[i] = random(-1, 1);
                    s[i] = random(w / 30, w / 10);
                    color[i] = rColor(gsc);
                    type[i] = rSeed(1);
                }

            },
            go() {
                var copies = this.copies;
                var x = this.x;
                var y = this.y;
                var vx = this.vx;
                var vy = this.vy;
                var s = this.s;
                var color = this.color;
                var type = this.type;

                for (let i = 0; i < copies; i++) {
                    x[i] += vx[i];
                    y[i] += vy[i];

                    if (x[i] > w || x[i] < 0) {
                        vx[i] *= -1
                    }
                    if (y[i] > w || y[i] < 0) {
                        vy[i] *= -1
                    }

                    ctx2.fillStyle = color[i];
                    ctx2.fillRect(
                        x[i],
                        y[i],
                        s[i],
                        s[i]
                    )
                }
            }
        }

        var text = {
            string: [
                "SHE'S",
                "GOT",
                "ME",
                "DAN",
                "CING"
            ],
            fs:h/10,
            lh:1,
            str: "SHE'S GOT ME DANCING",
            lines: 10,
            points: 50,
            l: [],
            init() {
                var letters = 0;
                for (let i = 0; i < this.lines; i++) {
                    this.l[i] = {
                        x: [],
                        y: [],
                        v: [],
                        color: rColor(gsc)
                    }
                    for (let j = 0; j < this.points; j++) {
                        this.l[i].x[j] = j * w / (this.points - 1);
                        this.l[i].y[j] = i * h / (this.lines - 2);
                        if (letters < this.string.length && rSeed(100) > 97&&i>3) {
                            
                            this.l[i].v[j] = this.string[letters];
                           // console.log('hi');
                            letters++
                        } else {
                            this.l[i].v[j] = 0;
                        }
                    }
                }
            },
            draw() {
                for (let i = 0; i < this.lines; i++) {
                    ctx.beginPath()
                    for (let j = 0; j < this.points; j++) {

                        //this.l[i].x[j] = j * w / this.points;
                        this.l[i].y[j] += Math.cos(time / 50 + this.l[i].x[j] / w * 5);
                        if (j == 0) {
                            ctx.moveTo(this.l[i].x[j], this.l[i].y[j])
                        } else {
                            ctx.lineTo(this.l[i].x[j], this.l[i].y[j])
                        }
                        ctx.font=this.fs+'px roboto';
                        ctx.textAlign="center";
                        ctx.fillStyle=strokeColor;
                        if (this.l[i].v[j] != 0) {
                            ctx.fillText(
                                this.l[i].v[j],
                                this.l[i].x[j],
                                this.l[i].y[j]
                            )
                        }
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = strokeColor //this.l[i].color;
                    ctx.stroke()
                }

            }
        }

        window.onload = function () {

            canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            document.body.appendChild(canvas);
            ctx = canvas.getContext("2d");
            gsc = rSeed(5);
            bg = rColor(gsc);
            strokeColor = rColor(gsc)

            canvas2 = document.createElement("canvas");
            canvas2.width = w;
            canvas2.height = h;
            document.body.appendChild(canvas2);
            ctx2 = canvas2.getContext("2d");
            bg2 = rColor(gsc);
            ctx2.fillStyle = bg2;
            ctx2.fillRect(0, 0, w, h)

            drama.init();
            text.init();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(65, w / h, 0.01, 2000);
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                //autoClear:false,
                //preserveDrawingBuffer: true ,
            });
            renderer.setSize(w, h);
            //renderer.autoClearColor = false;
            //document.body.appendChild(renderer.domElement);
            //renderer.shadowMap.enabled = true;
            //renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            camera.position.set(0, 0, 100);


            var ambientLight = new THREE.AmbientLight(0xcccccc, 0.1);
            scene.add(ambientLight);

            var pointLight = new THREE.PointLight(0xcccccc, 0.8);
            scene.add(pointLight);
            pointLight.position.set(100, 100, 100);
            // pointLight.castShadow = true;
            // pointLight.shadow.mapSize.width = 1024; // default
            // pointLight.shadow.mapSize.height = 1024; // default
            // pointLight.shadow.camera.near = 0.1; // default
            // pointLight.shadow.camera.far = 1000 // default
            map = new THREE.CanvasTexture(canvas2);
            pivot = new THREE.Object3D();
            var loader = new THREE.OBJLoader();
            loader.load(
                '/obj/man2.obj',
                function (obj) {
                    obj.traverse(
                        function (child) {
                            if (child.isMesh) {
                                var geometry = child.geometry;
                                var material = new THREE.MeshBasicMaterial({
                                    map: map,
                                    //wireframe:true,
                                    //roughness: 0.5,
                                    side: THREE.DoubleSide
                                })
                                for (let i = 0; i < 1; i++) {
                                    mesh[i] = new THREE.Mesh(geometry, material);
                                    pivot.add(mesh[i]);

                                }

                                l = mesh[0].geometry.attributes.position.array.length;

                                // mesh.castShadow = true;
                                //mesh.receiveShadow=true;

                            }
                        }
                    )
                    scene.add(pivot);
                    pivot.castShadow = true;
                    pivot.receiveShadow = true;
                    pivot.position.y = -50;
                    // pivot.rotation.y=;
                    var s = 25;
                    pivot.scale.set(s, s, s);
                    mesh[0].m = {
                        x: [0, 0],
                        y: [0, 0],
                        z: [0, 0],
                        lx: 0,
                        ly: 0,
                        lz: 0
                    };
                    for (let i = 0; i < l; i += 3) {
                        var x = mesh[0].geometry.attributes.position.array[i];
                        var y = mesh[0].geometry.attributes.position.array[i + 1];
                        var z = mesh[0].geometry.attributes.position.array[i + 2];
                        if (x > mesh[0].m.x[1]) mesh[0].m.x[1] = x;
                        if (x < mesh[0].m.x[0]) mesh[0].m.x[0] = x;

                        if (y > mesh[0].m.y[1]) mesh[0].m.y[1] = y;
                        if (y < mesh[0].m.y[0]) mesh[0].m.y[0] = y;

                        if (z > mesh[0].m.z[1]) mesh[0].m.z[1] = z;
                        if (z < mesh[0].m.z[0]) mesh[0].m.z[0] = z;
                    }
                    mesh[0].map = [];
                    mesh[0].m.lx = Math.abs(mesh[0].m.x[1] - mesh[0].m.x[0]);
                    mesh[0].m.ly = Math.abs(mesh[0].m.y[1] - mesh[0].m.y[0]);
                    mesh[0].m.lz = Math.abs(mesh[0].m.z[1] - mesh[0].m.z[0]);

                    for (let i = 0; i < l; i += 3) {
                        var index = mesh[0].map.length;
                        var x = mesh[0].geometry.attributes.position.array[i];
                        var y = mesh[0].geometry.attributes.position.array[i + 1];
                        var z = mesh[0].geometry.attributes.position.array[i + 2];
                        var t = 0;
                        for (let j = 0; j < index; j++) {
                            var x0 = mesh[0].geometry.attributes.position.array[mesh[0].map[j].x[0]];
                            var y0 = mesh[0].geometry.attributes.position.array[mesh[0].map[j].y[0]];
                            var z0 = mesh[0].geometry.attributes.position.array[mesh[0].map[j].z[0]];
                            if (x == x0 && y == y0 && z == z0) {
                                mesh[0].map[j].x.push(i);
                                mesh[0].map[j].y.push(i + 1);
                                mesh[0].map[j].z.push(i + 2);

                                t = 1;
                            }
                        }
                        if (t == 0) {
                            mesh[0].map[index] = {
                                x: [],
                                y: [],
                                z: [],
                                vx: 0,
                                vy: 0,
                                vz: 0,
                            };
                            mesh[0].map[index].x.push(i);
                            mesh[0].map[index].y.push(i + 1);
                            mesh[0].map[index].z.push(i + 2);
                            mesh[0].map[index].vx = x / mesh[0].m.lx;
                            mesh[0].map[index].vy = y / mesh[0].m.ly;
                            mesh[0].map[index].vz = z / mesh[0].m.lz;
                            var t = 0;
                        }

                    }
                },
                function onprogress() {},
                function onerror() {}
            )




            animate();

        }





        function animate() {

            if (mesh[0]) {
                for (let i = 0; i < mesh[0].map.length; i++) {
                    for (let j = 0; j < mesh[0].map[i].x.length; j++) {
                        var ix = mesh[0].map[i].x[j];
                        var iy = mesh[0].map[i].y[j];
                        var iz = mesh[0].map[i].z[j];

                        var point = mesh[0].geometry.attributes.position.array;

                        point[ix] += Math.cos(time / 10 + mesh[0].map[i].vy * 3) /
                            100 * mesh[0].map[i].vy;


                        point[iy] += Math.cos(time / 20 + mesh[0].map[i].vx * 10) /
                            50;

                        point[iz] += Math.cos(time / 30 + mesh[0].map[i].vy * 10) /
                            100;

                    }

                }
                mesh[0].geometry.attributes.position.needsUpdate = true;
                mesh[0].material.map.needsUpdate = true;

                //cube.geometry.computeBoundingSphere();
            }


            // mesh[0].geometry.attributes.position.dynamic=true;
            // mesh[0].geometry.attributes.position.normalized=true;


            pivot.rotation.y = Math.cos(time / 200) * Math.PI / 9 + Math.PI;
            //renderer.shadowMap.needsUpdate = true;
            renderer.render(scene, camera);
            drama.go();
            ctx.fillStyle = bg;
            //ctx.globalAlpha=0.1;
            ctx.fillRect(0, 0, w, h);
            //ctx.globalAlpha=1;
            text.draw();
            ctx.drawImage(renderer.domElement, 0, 0)

            requestAnimationFrame(animate);
            time++
        }




        function rColor(s) {
            var seed = Math.round(Math.random() * 4);
            var color = [];
            color[0] = ["#571845", "#900c3e", "#c70039", "#ff5733", "#ffc300"];
            color[1] = ["#96ceb4", "#ffeead", "#ff6f69", "#ffcc5c", "#88d8b0"];
            color[2] = ["#173f5f", "#20639b", "#3caea3", "#f6d55c", "#ed553b"];
            color[3] = ["#999", "#777", "#555", "#333", "#111"];
            color[4] = ["#ffa239", "#c8e6c9", "#81c784", "#4caf50", "#ffe789"];
            color[5] = ["#428", "#6ca2ea", "#b5d33d", "#fed23f", "#eb7d5b"];
            var rgb = color[s][seed];
            return rgb;
        };

        function random(minR, maxR) {
            var r = minR + (maxR - minR) * Math.random();
            return r
        };

        function rSeed(value) {
            var seed = Math.round(Math.random() * value);
            return seed
        };
    </script>

</body>

</html>