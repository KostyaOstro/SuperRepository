<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="/javascripts/three.js"></script>
    <script src="/javascripts/myLib.js"></script>
    <title>Document</title>
</head>

<body>
    <script>
        var time = 0;
        var w = h = 1024;

        var canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        var ctx = canvas.getContext("2d");
        document.body.appendChild(canvas);
        let s = 50;
        ctx.fillStyle = "white";
        ctx.fillRect(
            0, 0, w, h
        );
        ctx.fillStyle = "black";
        for (let i = 0; i < s; i++) {
            
            ctx.fillRect(
                random(0, w),
                0,
                random(5, 20),
                h
            )
        }

        if (ctx) {
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(65, w / h, .01, 2000);
            camera.position.z = 100;
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(w, h);
            document.body.appendChild(renderer.domElement);
            renderer.shadowMap.enabled = true;


            var aLight = new THREE.AmbientLight(new THREE.Color("blue"), .4);
            scene.add(aLight);

            var pLight = new THREE.PointLight(new THREE.Color("red"), 2);
            scene.add(pLight);
            pLight.position.set(100, 100, 100);
            pLight.castShadow = true;
            var tex = new THREE.CanvasTexture(canvas);
            var rface = {
                segmentNumber: 0,
                segment: [],
                headLength: 60,
                init() {

                    var type = rSeed(1);
                    var material = new THREE.MeshStandardMaterial({
                        color: "gray",
                        roughness: 0.8,
                        map: tex,
                    });
                    var material2 = new THREE.MeshBasicMaterial({

                    });
                    this.segmentNumber = rSeed(5) + 3;
                    let hh = this.headLength / this.segmentNumber;
                    for (let i = 0; i < this.segmentNumber; i++) {
                        this.segment[i] = new THREE.Object3D();
                        let ww = random(20, 60);
                        let dd = random(5, 20);
                        var geometry = new THREE.BoxBufferGeometry(ww, hh, dd, 1, 1, 1);


                        let box = new THREE.Mesh(geometry, material);
                        box.castShadow = true;
                        box.receiveShadow = true;
                        this.segment[i].add(box);

                        if (rSeed(2) > 1) {
                            let copies = rSeed(3) + 1;
                            for (let ii = 0; ii < copies; ii++) {
                                let ll = ww / 2 * random(1.1, 1.3);
                                var antenna = new THREE.Object3D();
                                var geometry = new THREE.BoxBufferGeometry(ll, .5, .5, 1, 1, 1);

                                let box2 = new THREE.Mesh(geometry, material);
                                box2.position.x = -ll / 2;
                                antenna.add(box2);

                                var geometry = new THREE.BoxBufferGeometry(2, 2, 2, 1, 1, 1);

                                let end1 = new THREE.Mesh(geometry, material);
                                end1.position.x = -ll;
                                antenna.add(end1);

                                antenna.rotation.z = ii * Math.PI / 2;
                                this.segment[i].add(antenna);
                            }
                        }

                        if (rSeed(2) > 1) {
                            if (rSeed(5) > 2) {
                                let cc = rSeed(1) + 1;
                                for (let jj = 0; jj < cc; jj++) {
                                    if (rSeed(2) > 1) {
                                        var geometry = new THREE.PlaneGeometry(
                                            random(2, 10),
                                            random(2, 10),
                                            1, 1);
                                    } else {
                                        let rr = random(2, 8);
                                        var geometry = new THREE.RingBufferGeometry(
                                            rr * random(0.2, 0.8),
                                            rr,
                                            20);
                                    }

                                    var eye = new THREE.Mesh(geometry, material2);
                                    eye.position.x = random(-ww / 2, ww / 2);
                                    eye.position.z = dd / 2;
                                    this.segment[i].add(eye);
                                }
                            } else {
                                let mouthSeg = rSeed(20) + 10;
                                let mouthW = random(5, ww);
                                for (let jj = 0; jj < mouthSeg; jj++) {
                                    var geometry = new THREE.PlaneGeometry(
                                        mouthW / mouthSeg * .8,
                                        random(2, 10),
                                        1, 1);
                                    var mseg = new THREE.Mesh(geometry, material2);
                                    mseg.position.z = dd / 2;
                                    mseg.position.x = -mouthW / 2 + mouthW / mouthSeg * jj;
                                    this.segment[i].add(mseg);
                                }
                            }
                        }



                        scene.add(this.segment[i]);
                        switch (type) {
                            case 0:

                                this.segment[i].position.y = -this.headLength / 2 + hh * i
                                break;
                            case 1:

                                this.segment[i].rotation.z = Math.PI / 2;
                                this.segment[i].position.x = -this.headLength / 2 + hh * i
                                break;
                        }


                    }
                }
            }

            rface.init();
            animate()
        }

        function animate() {
            // for (let i = 0; i < rface.segmentNumber; i++){
            //     rface.segment[i].rotation.y += Math.cos(i + time) / 200 ;
            // }
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
            time += .01;
        }
    </script>
</body>

</html>